<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="spaceCanvas"></canvas>

    <script>
        const canvas = document.getElementById('spaceCanvas');
        const ctx = canvas.getContext('2d');

        // --- TH√îNG S·ªê ƒêI·ªÄU KHI·ªÇN HI·ªÜU ·ª®NG ---
        const maxObjects = 100;
        const creationChance = 0.04; // TƒÉng nh·∫π c∆° h·ªôi t·∫°o ƒë·ªÉ th·∫•y hi·ªáu qu·∫£ t·ªët h∆°n

        // --- ·∫¢NH R∆†I ---
        const imageUrls = ['../image1.png', '../image2.png'];
        const loadedImages = [];
        imageUrls.forEach(src => {
            const img = new Image();
            img.src = src;
            img.onload = () => console.log(`Image ${src} loaded.`); // Ki·ªÉm tra ·∫£nh ƒë√£ t·∫£i
            img.onerror = () => console.error(`Failed to load image: ${src}`); // B√°o l·ªói n·∫øu ·∫£nh kh√¥ng t·∫£i ƒë∆∞·ª£c
            loadedImages.push(img);
        });

        // --- SAO ---
        const stars = [];
        const numStars = 2000;
        const starColors = ['#9bb0ff', '#8a9dff', '#e8dff5', '#f7f2ff', '#fffde8'];
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.radius = Math.random() * 1.2;
                this.color = starColors[Math.floor(Math.random() * starColors.length)];
                this.alpha = Math.random() * 0.5 + 0.5;
                this.twinkleSpeed = Math.random() * 0.015;
                this.twinkleDirection = 1;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.hexToRgb(this.color)}, ${this.alpha})`;
                ctx.fill();
            }
            update() {
                if (this.alpha > 1 || this.alpha < 0.2) this.twinkleDirection *= -1;
                this.alpha += this.twinkleSpeed * this.twinkleDirection;
                this.draw();
            }
            hexToRgb(hex) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; }
                else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
                return `${+r},${+g},${+b}`;
            }
        }
        function initStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) stars.push(new Star());
        }

        // --- C√ÅC CLASS V·∫¨T TH·ªÇ R∆†I ---
        const sentences = [
            'Happy Birthday ‚ú®',
            'Lu√¥n c∆∞·ªùi th·∫≠t t∆∞∆°i nha üòä',
            'Hope your day‚Äôs as special as you are üí´'
        ];
        const glowColors = [{ r: 70, g: 255, b: 233 }, { r: 255, g: 100, b: 233 }, { r: 150, g: 100, b: 255 }, { r: 255, g: 255, b: 150 }, { r: 100, g: 255, b: 100 }];

        class FallingText {
            constructor(allFallingTexts = []) {
                this.size = canvas.width * 0.03;
                const speedModifier = canvas.width > 768 ? 1.0 : 0.3;
                const baseSpeed = canvas.height * 0.0008 * speedModifier;
                this.speed = baseSpeed;
                this.color = glowColors[Math.floor(Math.random() * glowColors.length)];
                this.text = sentences[Math.floor(Math.random() * sentences.length)];
                ctx.font = `${this.size}px "Courier New", Courier, monospace`;

                // --- C·∫¨P NH·∫¨T LOGIC V·ªä TR√ç V√Ä VA CH·∫†M ---
                let finalX, finalY;
                const maxAttempts = 100; // TƒÉng s·ªë l·∫ßn th·ª≠ l√™n nhi·ªÅu h∆°n
                const minPadding = 20; // Kho·∫£ng ƒë·ªám t·ªëi thi·ªÉu gi·ªØa c√°c ch·ªØ

                // H√†m ki·ªÉm tra va ch·∫°m d·ª±a tr√™n bounding box
                const checkCollision = (newX, newY, newTextWidth, newTextHeight) => {
                    // T·∫°o bounding box cho ch·ªØ m·ªõi
                    const newLeft = newX - newTextWidth / 2 - minPadding / 2;
                    const newRight = newX + newTextWidth / 2 + minPadding / 2;
                    const newTop = newY - newTextHeight + minPadding / 2; // y l√† baseLine c·ªßa ch·ªØ
                    const newBottom = newY + minPadding / 2;

                    for (const otherText of allFallingTexts) {
                        ctx.font = `${otherText.size}px "Courier New", Courier, monospace`;
                        const otherTextWidth = ctx.measureText(otherText.text).width;
                        const otherTextHeight = otherText.size;

                        // T·∫°o bounding box cho ch·ªØ hi·ªán c√≥
                        const otherLeft = otherText.x - otherTextWidth / 2 - minPadding / 2;
                        const otherRight = otherText.x + otherTextWidth / 2 + minPadding / 2;
                        const otherTop = otherText.y - otherTextHeight + minPadding / 2;
                        const otherBottom = otherText.y + minPadding / 2;

                        // Ki·ªÉm tra va ch·∫°m (AABB collision detection)
                        if (newLeft < otherRight &&
                            newRight > otherLeft &&
                            newTop < otherBottom &&
                            newBottom > otherTop) {
                            return true; // B·ªã tr√πng
                        }
                    }
                    return false; // Kh√¥ng b·ªã tr√πng
                };

                const textWidth = ctx.measureText(this.text).width;
                const textHeight = this.size; // Chi·ªÅu cao c·ªßa ch·ªØ g·∫ßn ƒë√∫ng b·∫±ng size font

                for (let i = 0; i < maxAttempts; i++) {
                    // T·∫°o v·ªã tr√≠ X, Y ng·∫´u nhi√™n ho√†n to√†n
                    // ƒê·∫£m b·∫£o ch·ªØ n·∫±m trong gi·ªõi h·∫°n m√†n h√¨nh
                    const randomX = textWidth / 2 + Math.random() * (canvas.width - textWidth);
                    // V·ªã tr√≠ Y b·∫Øt ƒë·∫ßu ·ªü ph√≠a r·∫•t tr√™n m√†n h√¨nh ƒë·ªÉ ch√∫ng c√≥ th·ªÉ ph√¢n b·ªë d·ªçc t·ªët h∆°n
                    const randomY = -(Math.random() * canvas.height * 0.8) - textHeight;

                    if (!checkCollision(randomX, randomY, textWidth, textHeight)) {
                        finalX = randomX;
                        finalY = randomY;
                        break; // T√¨m ƒë∆∞·ª£c v·ªã tr√≠ an to√†n, tho√°t v√≤ng l·∫∑p
                    }
                }

                // N·∫øu sau nhi·ªÅu l·∫ßn th·ª≠ m√† v·∫´n kh√¥ng t√¨m ƒë∆∞·ª£c v·ªã tr√≠ l√Ω t∆∞·ªüng
                // (c√≥ th·ªÉ do m√†n h√¨nh qu√° ƒë·∫ßy ho·∫∑c ch·ªØ qu√° l·ªõn),
                // ta v·∫´n ƒë·∫∑t n√≥ v√†o m·ªôt v·ªã tr√≠ ng·∫´u nhi√™n cu·ªëi c√πng.
                // ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o ch·ªØ lu√¥n ƒë∆∞·ª£c t·∫°o ra, d√π c√≥ th·ªÉ h∆°i ch·ªìng ch√©o
                // trong tr∆∞·ªùng h·ª£p c·ª±c ƒëoan.
                this.x = finalX !== undefined ? finalX : textWidth / 2 + Math.random() * (canvas.width - textWidth);
                this.y = finalY !== undefined ? finalY : -(Math.random() * canvas.height * 0.6) - textHeight;
            }

            update() {
                ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.8)`;
                ctx.shadowBlur = 15;
                ctx.fillStyle = 'white';
                ctx.font = `${this.size}px "Courier New", Courier, monospace`;
                ctx.textAlign = "center";
                ctx.fillText(this.text, this.x, this.y);
                ctx.shadowBlur = 0;
                this.y += this.speed;
                return this.y < canvas.height + this.size;
            }
        }

        class FallingImage {
            constructor() {
                this.y = -100;
                const speedModifier = canvas.width > 768 ? 1.0 : 0.3;
                const baseSpeed = canvas.height * 0.0007 * speedModifier;
                this.speed = (Math.random() * baseSpeed) + baseSpeed;
                const minSize = canvas.width * 0.03;
                const maxSize = canvas.width * 0.06;
                this.size = Math.random() * (maxSize - minSize) + minSize;
                this.x = Math.random() * (canvas.width - this.size);
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.img = loadedImages[Math.floor(Math.random() * loadedImages.length)];
            }
            update() {
                // Ki·ªÉm tra ·∫£nh ƒë√£ t·∫£i xong v√† c√≥ k√≠ch th∆∞·ªõc t·ª± nhi√™n h·ª£p l·ªá
                if (!this.img || !this.img.complete || this.img.naturalWidth === 0 || this.img.naturalHeight === 0) {
                    return true; // Gi·ªØ l·∫°i object n·∫øu ·∫£nh ch∆∞a s·∫µn s√†ng
                }
                ctx.save();
                ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
                ctx.rotate(this.rotation);
                ctx.drawImage(this.img, -this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                return this.y < canvas.height + this.size;
            }
        }

        class FallingLight {
            constructor() {
                this.y = -50;
                this.radius = Math.random() * 2 + 1.5;
                const speedModifier = canvas.width > 768 ? 1.0 : 0.3;
                const baseSpeed = canvas.height * 0.0006 * speedModifier;
                this.speed = (Math.random() * baseSpeed) + baseSpeed;
                this.color = glowColors[Math.floor(Math.random() * glowColors.length)];
                const glowSize = this.radius * 5;
                const safeArea = canvas.width - (glowSize * 2);
                this.x = (Math.random() * safeArea) + glowSize;
            }
            update() {
                const glowSize = this.radius * 5;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.9)`);
                gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                this.y += this.speed;
                return this.y < canvas.height + glowSize;
            }
        }

        let fallingImages = [];
        let fallingTexts = [];
        let fallingLights = [];

        function createFallingObject() {
            const rand = Math.random();
            if (rand < 0.35 && loadedImages.length > 0) {
                fallingImages.push(new FallingImage());
            } else if (rand < 0.75) {
                // Truy·ªÅn m·∫£ng c√°c ch·ªØ hi·ªán c√≥ v√†o ƒë·ªÉ so s√°nh v·ªã tr√≠
                fallingTexts.push(new FallingText(fallingTexts));
            } else {
                fallingLights.push(new FallingLight());
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => star.update());

            const totalObjects = fallingImages.length + fallingTexts.length + fallingLights.length;
            if (totalObjects < maxObjects && Math.random() < creationChance) {
                createFallingObject();
            }

            fallingImages = fallingImages.filter(obj => obj.update());
            fallingTexts = fallingTexts.filter(obj => obj.update());
            fallingLights = fallingLights.filter(obj => obj.update());

            requestAnimationFrame(animate);
        }

        function onResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // X√≥a t·∫•t c·∫£ c√°c v·∫≠t th·ªÉ khi resize ƒë·ªÉ tr√°nh l·ªói v·ªã tr√≠
            fallingImages = [];
            fallingTexts = [];
            fallingLights = [];
            initStars();
        }

        window.addEventListener('resize', onResize);
        onResize();
        animate();
    </script>
</body>

</html>